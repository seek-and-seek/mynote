从错误信息来看，问题在于你使用了单引号 `'` 来表示字符串，但 Java 中，字符串应该用双引号 `"` 括起来，而字符应该用单引号 `'`。你写的 `String book1 = '《三体1》';` 语法上是错误的，因为 `'` 只能用来表示单个字符，而不是字符串

如果两个char类型的变量直接相加，最终都得整数



/n /t等在“”中仍有效

​	char gender = myscanner.next().charAt(0);//先接收字符串，再取出第一个字符。

~~~java
	char gender = myscanner.next().charAt(0);//先接收字符串，再取出第一个字符
~~~

在 Java 中，一个源文件中允许定义多个类，但最多只能有一个用 public 修饰的顶级类，并且这个 public 类的名字必须与源文件名完全一致。这背后主要有以下几个原因：

1. **编译单元的设计**
   每个 .java 文件被视为一个编译单元（translation unit），在这个单元中只有一个对外暴露的公共接口，这个接口就是那个 public 类。这样设计使得编译器和类加载器能快速且唯一地确定一个类的入口，从而避免混淆。
2. **类加载和命名约束**
   Java 编译器在生成 .class 文件时，会根据 public 类的名字生成相应的字节码文件。如果一个文件中存在多个 public 类，那么生成的字节码文件数量和名字将无法与源文件对应，这会导致类加载时的混乱和定位困难。要求文件名与 public 类名一致可以确保加载机制的正确性。
3. **提高代码的清晰性和可维护性**
   这种约定使得开发者在查看源文件时，可以迅速知道这个文件主要暴露的是哪个公共类，进而理解整个程序的结构。其它非 public 类则作为内部实现细节对外隐藏，降低耦合度，提升代码维护性。

总的来说，这一规则既是 Java 语言规范的要求，也是为了让编译、加载和维护代码更加高效和清晰。



**编译类型**
 这是在变量声明时确定的类型，也称为静态类型。编译器在编译时只根据这一类型来检查代码的合法性，比如确定哪些方法和属性是可以访问的

变量 **p** 的编译类型是 **Person**，这意味着在编译阶段，只有 **Person** 类中定义的方法和属性能被调用或访问，即使实际对象是 **Student** 类型的。

**运行类型**

这是在程序运行时实际分配的对象类型，也称为动态类型





f

t String型方法重写比内容

f

t

f



t

t / /自动转换

t

f

t

！







第一个月 1对    1

第二个月 1对     

第三个月  2对（第一个月的可以生了）

四                3        

五                5         

六                8

也就是每次能生的是：原来能生的加 前个月的（前个月：现月减2）



public 本类，包内，子类 不同包

protected

super  name g1（）

this id score f1（）nmae g1（）

super name = AA id 

this name = BB g1（）show()g1()



 Test 		 Doem Rose jack

john jack

wget https://github.com/ClassmateLin/dm-ticket/releases/download/v0.1.0/dm-ticket.zip
